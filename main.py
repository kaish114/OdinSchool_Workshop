# Import necessary libraries
import os
from dotenv import load_dotenv
import telegram
from telegram.ext import CommandHandler, MessageHandler, filters, Application
import openai
import g4f
import concurrent.futures
import tracemalloc

# Create a ThreadPoolExecutor for running g4f operations
executor = concurrent.futures.ThreadPoolExecutor()

# Define a function to handle G4F (GPT-3.5) messages
def handle_g4f_message(message):
    """
    Handles G4F (GPT-3.5) message generation.

    Args:
    message (str): The user's input message.

    Returns:
    str: The response generated by the GPT-3.5 model.
    """
    response = g4f.ChatCompletion.create(
        model="gpt-3.5-turbo",
        provider=g4f.Provider.DeepAi,
        messages=[{"role": "user", "content": message}],
    )
    return response

# Load environment variables from a .env file
load_dotenv()

# Set up OpenAI API key from environment variables
openai.api_key = os.getenv('OPENAI_KEY')

# Set up Telegram bot token from environment variables
TOKEN = os.getenv('TG_BOT_TOKEN')

# Create a Telegram Bot instance
bot = telegram.Bot(token=TOKEN)

# Define a function to handle the '/start' command from users
async def start(update, context):
    """
    Handles the '/start' command from users.

    Args:
    update (telegram.Update): The update object containing information about the user.
    context (telegram.ext.CallbackContext): The context for handling the command.

    Returns:
    None
    """
    first_name = update.message.chat.first_name
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Hello {}! Welcome to the AI Bot. How can I help you today?".format(first_name)
    )

# Define a function to handle user messages and generate responses
async def echo(update, context):
    """
    Handles user messages and generates responses using either OpenAI or G4F (GPT-3.5).

    Args:
    update (telegram.Update): The update object containing the user's message.
    context (telegram.ext.CallbackContext): The context for handling the message.

    Returns:
    None
    """
    message = update.message.text
    
    if os.getenv('OPENAI_KEY'):
        # Use OpenAI to generate a response if an OpenAI API key is available
        response = openai.Completion.create(
            engine="text-davinci-002",
            prompt=message,
            temperature=0,
            max_tokens=1000,
            top_p=1,
            frequency_penalty=0,
            presence_penalty=0
        )
        
        if response:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=response.choices[0].text
            )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text='Please share your question one more time!'
            )
    else:
        # Use the ThreadPoolExecutor to asynchronously generate a response with G4F
        response_future = executor.submit(handle_g4f_message, message)
        response = response_future.result()
        
        if response:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=response
            )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text='Please share your question one more time!'
            )

# Define the main function to set up the Telegram bot and handle commands and messages
def main():
    """
    Main function to set up and run the Telegram bot.

    Returns:
    None
    """
    # Create an Application instance for the Telegram bot
    application = Application.builder().token(TOKEN).build()
    
    # Add command and message handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, echo))
    
    # Start polling for updates from Telegram
    print("AI bot is running...")
    application.run_polling()

if __name__ == '__main__':
    main()
